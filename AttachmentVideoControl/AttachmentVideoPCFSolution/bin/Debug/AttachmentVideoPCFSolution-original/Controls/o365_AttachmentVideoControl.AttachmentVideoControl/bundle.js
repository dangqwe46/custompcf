/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
var pcf_tools_652ac3f36e1e4bca82eb3c1dc44e6fad;
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./AttachmentVideoControl/index.ts":
/*!*****************************************!*\
  !*** ./AttachmentVideoControl/index.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AttachmentVideoControl: () => (/* binding */ AttachmentVideoControl)\n/* harmony export */ });\n/**\r\n * EntityReference class\r\n * @param typeName - The type name of the entity\r\n * @param id - The id of the entity\r\n */\nclass EntityReference {\n  constructor(typeName, id) {\n    this.id = id;\n    this.typeName = typeName;\n  }\n}\n/**\r\n * AttachedFile class\r\n * @param annotationId - The id of the annotation\r\n * @param fileName - The name of the file\r\n * @param mimeType - The mime type of the file\r\n * @param fileContent - The content of the file\r\n * @param fileSize - The size of the file\r\n */\nclass AttachedFile {\n  constructor(annotationId, fileName, mimeType, fileContent, fileSize) {\n    this.annotationId = annotationId;\n    this.fileName = fileName;\n    this.mimeType = mimeType;\n    this.fileContent = fileContent;\n    this.fileSize = fileSize;\n  }\n}\n/**\r\n * AttachmentVideoControl class\r\n * @param context - The context of the control\r\n * @param notifyOutputChanged - A callback method to alert the framework that the control has new outputs ready to be retrieved asynchronously.\r\n * @param state - A piece of data that persists in one session for a single user. Can be set at any point in a controls life cycle by calling 'setControlState' in the Mode interface.\r\n */\nclass AttachmentVideoControl {\n  /**\r\n   * Empty constructor.\r\n   */\n  constructor() {\n    this.errorLabel = null;\n    this.currentAnnotationId = null;\n    this.videoNameLabel = null;\n    this.isMobileDevice = false;\n    this.loadingLabel = null;\n    this.videoContainer = null;\n    this.isLoading = false;\n    this.debugLabel = null;\n    this.isDebugMode = false; // turn on/off debug mode\n    this.supportedVideoFormats = ['video/mp4'];\n    // Track user interaction for iOS auto-play restrictions\n    this.hasUserInteracted = false;\n    this.toBase64String = (file, successFn) => {\n      var reader = new FileReader();\n      reader.readAsDataURL(file);\n      reader.onload = () => successFn(file, reader.result);\n      return reader.result;\n    };\n    this.uploadFn = () => {\n      // Show loading while processing upload\n      this.showLoading(true);\n      try {\n        var fileUpload = document.getElementById('fileUpload');\n        var files = fileUpload.files;\n        var valid = fileUpload.files && fileUpload.files.length > 0;\n        if (!valid) {\n          this.showLoading(false);\n          this.showError('Please select the video file!');\n          return;\n        }\n        var file = files[0];\n        // Check file size - limit to 50MB\n        var MAX_FILE_SIZE = 50 * 1024 * 1024; // 50MB in bytes\n        if (file.size > MAX_FILE_SIZE) {\n          this.showLoading(false);\n          this.showError(\"Error: Video size exceeds the maximum limit of 50MB.\");\n          return;\n        }\n        // Check if video format is supported\n        if (!this.supportedVideoFormats.includes(file.type)) {\n          this.showLoading(false);\n          this.showError('Unsupported video format. Please use MP4 format.');\n          return;\n        }\n        // Format is supported, process directly\n        this.processVideoUpload(file);\n      } catch (error) {\n        this.showLoading(false);\n        console.error(\"Error in upload function:\", error);\n        this.showError(\"Failed to process video upload.\");\n      }\n    };\n    this.renderToPlayer = (body, type) => {\n      // Only proceed if we have content\n      if (!body || !type) {\n        console.error(\"Missing video data or type\");\n        this.showLoading(false);\n        this.showUploadButton(true);\n        return;\n      }\n      try {\n        var videoElement = document.getElementById('videoElement');\n        if (!videoElement) {\n          console.error(\"Video element not found\");\n          this.showLoading(false);\n          this.showUploadButton(true);\n          return;\n        }\n        var existingPlayer = document.getElementById('elementPlayer');\n        if (existingPlayer) {\n          existingPlayer.remove();\n        }\n        var sourceElement = document.createElement('source');\n        sourceElement.id = 'elementPlayer';\n        sourceElement.src = body;\n        sourceElement.type = type;\n        videoElement.appendChild(sourceElement);\n        // Add fallback text for unsupported formats\n        videoElement.innerHTML += '<p>Your browser does not support this video format.</p>';\n        // For mobile devices, especially iOS, we need to handle loading differently\n        videoElement.load();\n        // Show the video player only after video is loaded\n        this.showVideoPlayer();\n        // Auto-play when possible, with fallbacks for mobile restrictions\n        if (this.hasUserInteracted) {\n          var playPromise = videoElement.play();\n          // Handle potential rejection due to mobile autoplay policies\n          if (playPromise !== undefined) {\n            playPromise.catch(error => {\n              console.log('Auto-play prevented:', error);\n              // We don't show an error as this is expected on mobile\n            });\n          }\n        }\n      } catch (error) {\n        console.error(\"Error rendering video:\", error);\n        this.showError(\"Failed to display video.\");\n        this.showLoading(false);\n        this.showUploadButton(true);\n      }\n    };\n    this.showToPlayer = (context, id) => {\n      // Keep loading visible while retrieving\n      this.showLoading(true);\n      this.showUploadButton(false);\n      // Use standard WebAPI - it handles offline mode automatically\n      context.webAPI.retrieveRecord(\"annotation\", id, \"?$select=documentbody,mimetype,filename\").then(attachment => {\n        var body = attachment.documentbody;\n        var type = attachment.mimetype;\n        this.renderToPlayer(\"data:\".concat(type, \";base64,\").concat(body), type);\n        // Update the video name if available\n        if (attachment.filename) {\n          this.updateVideoNameLabel(attachment.filename);\n        }\n        // Show the video player\n        this.showVideoPlayer();\n        // Now that video is rendered, hide loading and show upload button\n        this.showLoading(false);\n        this.showUploadButton(true);\n        return attachment;\n      }).catch(error => {\n        // Hide loading on error and show upload button\n        this.showLoading(false);\n        this.showUploadButton(true);\n        console.error(\"Error retrieving annotation:\", error);\n        this.showError(\"Failed to load video.\");\n        return error;\n      });\n    };\n    this.addAttachments = file => {\n      // Performance optimization: Create entity object once\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      var notesEntity = {};\n      // Use more efficient regex to handle different video types\n      var fileContent = file.fileContent.replace(/^data:[^;]+;base64,/, \"\");\n      // Set properties efficiently in a batch\n      Object.assign(notesEntity, {\n        \"documentbody\": fileContent,\n        \"filename\": file.fileName,\n        \"filesize\": file.fileSize,\n        \"mimetype\": file.mimeType,\n        \"subject\": file.fileName,\n        \"notetext\": \"Video Attachment of \" + this.entityReference.typeName,\n        \"objecttypecode\": this.entityReference.typeName,\n        [\"objectid_\".concat(this.entityReference.typeName, \"@odata.bind\")]: \"/\".concat(this.CollectionNameFromLogicalName(this.entityReference.typeName), \"(\").concat(this.entityReference.id, \")\")\n      });\n      // Check for existing video for this entity and set the annotation ID\n      this.checkIsExistingVideo(this.entityReference.id).then(annotationId => {\n        // If we have an annotation ID, update it\n        if (annotationId) {\n          this.currentAnnotationId = annotationId;\n          this.updateAttachment(annotationId, notesEntity);\n        } else {\n          // No existing annotation, create a new one\n          this.currentAnnotationId = null;\n          this.createNewAnnotation(notesEntity);\n        }\n        return annotationId;\n      }).catch(error => {\n        console.error(\"Error checking for existing video:\", error);\n        // Create a new annotation as fallback\n        this.createNewAnnotation(notesEntity);\n        return error;\n      });\n    };\n    /**\r\n     * Delete the current video\r\n     */\n    this.deleteVideoFn = () => {\n      if (!this.currentAnnotationId) {\n        this.showError(\"No video to delete.\");\n        return;\n      }\n      if (confirm(\"Are you sure you want to delete this video?\")) {\n        // Show loading while checking\n        this.showLoading(true);\n        // First verify the annotation ID is still valid\n        this.checkIsExistingVideo(this.entityReference.id).then(annotationId => {\n          if (!annotationId || annotationId !== this.currentAnnotationId) {\n            // Annotation is already gone or has changed\n            this.showLoading(false);\n            this.clearVideoPlayer();\n            this.hideDeleteButton();\n            this.hideVideoNameLabel();\n            this.currentAnnotationId = null;\n            this.showInfo(\"Video already deleted or changed.\");\n            return null;\n          }\n          // Annotation exists, proceed with deletion\n          return this._context.webAPI.deleteRecord(\"annotation\", annotationId).then(() => {\n            this.showLoading(false);\n            this.clearVideoPlayer();\n            this.hideDeleteButton();\n            this.hideVideoNameLabel();\n            this.currentAnnotationId = null;\n            this.showSuccess(\"Video deleted successfully!\");\n            return true;\n          }).catch(error => {\n            this.showLoading(false);\n            console.error(\"Error deleting video:\", error);\n            this.showError(\"Failed to delete video.\");\n            return error;\n          });\n        }).catch(error => {\n          this.showLoading(false);\n          console.error(\"Error checking video existence:\", error);\n          this.showError(\"Failed to check if video exists.\");\n          return error;\n        });\n      }\n    };\n    /**\r\n     * Check if video exists for the current record and return its ID\r\n     * @param entityReferenceId The ID of the entity to check\r\n     * @returns Promise<string> The annotation ID if found, empty string otherwise\r\n     */\n    this.checkIsExistingVideo = entityReferenceId => {\n      return new Promise(resolve => {\n        if (!entityReferenceId) {\n          this.debugInfo('No entityReferenceId provided to checkIsExistingVideo');\n          resolve(\"\");\n          return;\n        }\n        // For mobile devices, use a different approach to avoid caching issues\n        if (this.isMobileDevice) {\n          this.debugInfo('Using mobile-specific retrieval approach');\n          // Use a direct fetch against the entity to get all related annotations\n          // and sort them manually to avoid caching issues\n          // The entityset name is plural of the entity logical name\n          var entitySet = this.CollectionNameFromLogicalName(this.entityReference.typeName);\n          // Get parent record with annotations expanded\n          var expandQuery = \"\".concat(entitySet, \"(\").concat(entityReferenceId, \")?$expand=o365m_fileattachment_Annotations($select=annotationid,createdon;$orderby=createdon desc;$top=1)\");\n          this.debugInfo(\"Mobile expand query: \".concat(expandQuery));\n          this._context.webAPI.retrieveRecord(this.entityReference.typeName, entityReferenceId, \"?$expand=o365m_fileattachment_Annotations($select=annotationid,createdon;$orderby=createdon desc;$top=1)\")\n          // eslint-disable-next-line @typescript-eslint/no-explicit-any\n          .then(result => {\n            // Check if we have annotations in the result\n            if (result.o365m_fileattachment_Annotations && result.o365m_fileattachment_Annotations.length > 0) {\n              // Take the latest annotation by created date\n              var latestAnnotation = result.o365m_fileattachment_Annotations[0];\n              var annotationId = latestAnnotation.annotationid;\n              this.debugInfo(\"Mobile approach: Found annotation ID: \".concat(annotationId));\n              resolve(annotationId);\n            } else {\n              this.debugInfo('Mobile approach: No annotations found');\n              resolve(\"\");\n            }\n            return result;\n          }).catch(error => {\n            this.debugInfo(\"Mobile approach error: \".concat(this.formatError(error)));\n            // Fallback to standard approach if the expand query fails\n            this.standardAnnotationQuery(entityReferenceId, resolve);\n            return error;\n          });\n        } else {\n          // For desktop, use standard approach\n          this.standardAnnotationQuery(entityReferenceId, resolve);\n        }\n      });\n    };\n    this.CollectionNameFromLogicalName = entityLogicalName => {\n      if (entityLogicalName[entityLogicalName.length - 1] != 's') {\n        return \"\".concat(entityLogicalName, \"s\");\n      } else {\n        return \"\".concat(entityLogicalName, \"es\");\n      }\n    };\n    // Empty\n  }\n  /**\r\n   * Used to initialize the control instance. Controls can kick off remote server calls and other initialization actions here.\r\n   * Data-set values are not initialized here, use updateView.\r\n   * @param context The entire property bag available to control via Context Object; It contains values as set up by the customizer mapped to property names defined in the manifest, as well as utility functions.\r\n   * @param notifyOutputChanged A callback method to alert the framework that the control has new outputs ready to be retrieved asynchronously.\r\n   * @param state A piece of data that persists in one session for a single user. Can be set at any point in a controls life cycle by calling 'setControlState' in the Mode interface.\r\n   * @param container If a control is marked control-type='standard', it will receive an empty div element within which it can render its content.\r\n   */\n  init(context, notifyOutputChanged, state, container) {\n    this._context = context;\n    this.entityReference = new EntityReference(\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    context.page.entityTypeName,\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    context.page.entityId);\n    // Detect if running on mobile device\n    this.isMobileDevice = this.detectMobileDevice();\n    var controlContainer = document.createElement('div');\n    controlContainer.className = 'video-control-container';\n    controlContainer.style.width = '100%';\n    controlContainer.style.maxWidth = this.isMobileDevice ? '100%' : '800px';\n    controlContainer.style.margin = '0 auto';\n    // Video name label\n    this.videoNameLabel = document.createElement('div');\n    this.videoNameLabel.style.marginBottom = '10px';\n    this.videoNameLabel.style.fontSize = '14px';\n    this.videoNameLabel.style.fontWeight = 'bold';\n    this.videoNameLabel.style.color = '#333';\n    this.videoNameLabel.style.padding = '5px 0';\n    this.videoNameLabel.style.display = 'none'; // Initially hidden\n    controlContainer.appendChild(this.videoNameLabel);\n    // Debug label - for showing query strings and debug info\n    this.debugLabel = document.createElement('div');\n    this.debugLabel.style.marginBottom = '10px';\n    this.debugLabel.style.fontSize = '12px';\n    this.debugLabel.style.fontFamily = 'monospace';\n    this.debugLabel.style.whiteSpace = 'pre-wrap';\n    this.debugLabel.style.wordBreak = 'break-all';\n    this.debugLabel.style.color = '#666';\n    this.debugLabel.style.padding = '5px';\n    this.debugLabel.style.border = '1px dashed #ccc';\n    this.debugLabel.style.backgroundColor = '#f9f9f9';\n    this.debugLabel.style.display = this.isDebugMode ? 'block' : 'none';\n    this.debugLabel.textContent = 'Debug information will appear here';\n    controlContainer.appendChild(this.debugLabel);\n    // Create error label (hidden by default)\n    this.errorLabel = document.createElement('div');\n    this.errorLabel.id = 'errorMessage';\n    this.errorLabel.style.color = '#e74c3c';\n    this.errorLabel.style.backgroundColor = '#fadbd8';\n    this.errorLabel.style.padding = '10px';\n    this.errorLabel.style.marginBottom = '15px';\n    this.errorLabel.style.borderRadius = '4px';\n    this.errorLabel.style.fontWeight = 'bold';\n    this.errorLabel.style.display = 'none';\n    this.errorLabel.style.width = '100%';\n    this.errorLabel.style.boxSizing = 'border-box';\n    controlContainer.appendChild(this.errorLabel);\n    // File upload section\n    var uploadSection = document.createElement('div');\n    uploadSection.id = 'uploadSection';\n    uploadSection.className = 'upload-section';\n    uploadSection.style.marginBottom = '15px';\n    uploadSection.style.display = 'none'; // Start hidden until loading completes\n    uploadSection.style.flexWrap = 'wrap';\n    uploadSection.style.alignItems = 'center';\n    uploadSection.style.gap = '10px';\n    uploadSection.style.justifyContent = 'flex-start'; // Ensure items align to the left\n    // Create a custom file input wrapper for better styling\n    var fileInputWrapper = document.createElement('div');\n    fileInputWrapper.style.position = 'relative';\n    fileInputWrapper.style.overflow = 'hidden';\n    fileInputWrapper.style.flexGrow = '0'; // Prevent growth\n    fileInputWrapper.style.flexShrink = '0'; // Prevent shrinking\n    fileInputWrapper.style.minWidth = '120px'; // Minimum width\n    fileInputWrapper.style.order = '1'; // Force order to be first\n    // Custom button that will trigger the file input\n    var customButton = document.createElement('button');\n    customButton.innerHTML = 'Choose Video';\n    customButton.setAttribute('style', 'padding:' + (this.isMobileDevice ? '10px 16px' : '4px 10px') + ';cursor:pointer;background-color:#0078d4;color:white;border:none;' + 'border-radius:4px;font-size:' + (this.isMobileDevice ? '16px' : '13px') + ';width:auto;min-width:' + (this.isMobileDevice ? '140px' : '120px') + ';max-width:100%;text-overflow:ellipsis;' + 'white-space:nowrap;overflow:hidden;transition:background-color 0.3s;height:' + (this.isMobileDevice ? 'auto' : '28px') + ';line-height:' + (this.isMobileDevice ? 'normal' : '20px') + ';');\n    customButton.onmouseover = () => {\n      customButton.style.backgroundColor = '#106ebe';\n    };\n    customButton.onmouseout = () => {\n      customButton.style.backgroundColor = '#0078d4';\n    };\n    fileInputWrapper.appendChild(customButton);\n    // Real file input (hidden behind the custom button)\n    var uploadInput = document.createElement('input');\n    uploadInput.id = 'fileUpload';\n    uploadInput.type = 'file';\n    uploadInput.accept = 'video/mp4'; // Limit to supported format\n    uploadInput.setAttribute('style', 'position:absolute;top:0;left:0;opacity:0;width:100%;height:100%;cursor:pointer;');\n    uploadInput.onchange = () => {\n      this.uploadFn();\n      // Update button text to show selected file\n      var fileName = uploadInput.files && uploadInput.files.length > 0 ? uploadInput.files[0].name : 'Choose Video';\n      // Truncate filename to 15 characters for button display\n      customButton.innerHTML = fileName.length > 15 ? fileName.substring(0, 12) + '...' : fileName;\n    };\n    fileInputWrapper.appendChild(uploadInput);\n    // Button container for actions\n    var buttonContainer = document.createElement('div');\n    buttonContainer.style.display = 'flex';\n    buttonContainer.style.flexGrow = '0';\n    buttonContainer.style.flexShrink = '0';\n    buttonContainer.style.order = '2'; // Set order to be second\n    // Delete video button\n    var deleteButton = document.createElement('button');\n    deleteButton.innerHTML = 'Delete Video';\n    deleteButton.id = 'deleteVideoBtn';\n    deleteButton.setAttribute('style', 'padding:' + (this.isMobileDevice ? '10px 16px' : '4px 10px') + ';cursor:pointer;background-color:#d9534f;color:white;border:none;' + 'border-radius:4px;font-size:' + (this.isMobileDevice ? '16px' : '13px') + ';transition:background-color 0.3s;height:' + (this.isMobileDevice ? 'auto' : '28px') + ';line-height:' + (this.isMobileDevice ? 'normal' : '20px') + ';');\n    deleteButton.onmouseover = () => {\n      deleteButton.style.backgroundColor = '#c9302c';\n    };\n    deleteButton.onmouseout = () => {\n      deleteButton.style.backgroundColor = '#d9534f';\n    };\n    deleteButton.onclick = () => this.deleteVideoFn();\n    deleteButton.style.display = 'none'; // Initially hidden\n    // Add buttons to container\n    buttonContainer.appendChild(deleteButton);\n    uploadSection.appendChild(fileInputWrapper);\n    uploadSection.appendChild(buttonContainer);\n    controlContainer.appendChild(uploadSection);\n    // Loading indicator - shown in place of the upload section\n    this.loadingLabel = document.createElement('div');\n    this.loadingLabel.textContent = 'Loading video...';\n    this.loadingLabel.style.padding = '15px';\n    this.loadingLabel.style.backgroundColor = '#f8f8f8';\n    this.loadingLabel.style.color = '#333';\n    this.loadingLabel.style.borderRadius = '4px';\n    this.loadingLabel.style.textAlign = 'center';\n    this.loadingLabel.style.marginBottom = '15px';\n    this.loadingLabel.style.display = 'none'; // Initially hidden\n    this.loadingLabel.style.width = '100%'; // Full width\n    this.loadingLabel.style.maxWidth = '300px'; // Limit width for better appearance\n    controlContainer.appendChild(this.loadingLabel);\n    // Video player container for responsive sizing - MOVED AFTER loading indicator\n    var videoContainer = document.createElement('div');\n    videoContainer.style.position = 'relative';\n    videoContainer.style.width = '100%';\n    videoContainer.style.paddingTop = '56.25%'; // 16:9 aspect ratio\n    videoContainer.style.backgroundColor = '#f5f5f5';\n    videoContainer.style.borderRadius = '4px';\n    videoContainer.style.overflow = 'hidden';\n    videoContainer.style.display = 'none'; // Initially hidden\n    this.videoContainer = videoContainer;\n    // Video player element\n    var videoElement = document.createElement('video');\n    videoElement.id = 'videoElement';\n    videoElement.setAttribute('style', 'position:absolute;top:0;left:0;width:100%;height:100%;object-fit:contain;');\n    videoElement.controls = true;\n    videoElement.playsInline = true; // Important for iOS\n    videoElement.setAttribute('playsinline', ''); // Additional iOS support\n    videoElement.setAttribute('webkit-playsinline', ''); // Older iOS support\n    // For iOS, need to manage auto-play restrictions\n    videoElement.muted = true; // Initially muted to allow auto-play on iOS\n    videoElement.addEventListener('canplay', () => {\n      // Auto-unmute after user interaction\n      if (this.hasUserInteracted) {\n        videoElement.muted = false;\n      }\n    });\n    var sourceElement = document.createElement('source');\n    sourceElement.id = 'elementPlayer';\n    sourceElement.src = '';\n    sourceElement.type = 'video/mp4';\n    videoElement.appendChild(sourceElement);\n    videoContainer.appendChild(videoElement);\n    controlContainer.appendChild(videoContainer);\n    container.appendChild(controlContainer);\n    // Add responsive styles for different screen sizes, with special handling for mobile\n    var styleElement = document.createElement('style');\n    styleElement.innerHTML = \"\\n            @media screen and (max-width: 600px) {\\n                .upload-section {\\n                    flex-direction: row;\\n                    flex-wrap: wrap;\\n                    justify-content: flex-start;\\n                    gap: 8px;\\n                }\\n                .upload-section > div {\\n                    margin-bottom: 8px;\\n                }\\n            }\\n            \\n            /* Specific mobile app styling */\\n            @media (hover: none) and (pointer: coarse) {\\n                button {\\n                    min-height: 44px; /* iOS minimum touch target */\\n                }\\n            }\\n            \\n            /* Desktop specific styles */\\n            @media (hover: hover) and (pointer: fine) {\\n                button {\\n                    min-height: 28px; /* Smaller buttons on desktop */\\n                }\\n            }\\n        \";\n    document.head.appendChild(styleElement);\n    // Detect network status changes for offline mode\n    this.setupNetworkDetection();\n    // Show loading state at start\n    this.showLoading(true);\n    // Check if there's existing video for this record\n    this.checkForExistingVideo();\n  }\n  /**\r\n   * Setup network detection to handle online/offline transitions\r\n   */\n  setupNetworkDetection() {\n    window.addEventListener('online', () => {\n      console.log('Network connection restored');\n      // Re-sync data when coming back online\n      if (this.entityReference.id) {\n        this.checkForExistingVideo();\n      }\n    });\n    window.addEventListener('offline', () => {\n      console.log('Network connection lost');\n      this.showInfo('You are offline. Limited functionality available.');\n    });\n  }\n  /**\r\n   * Detect if running on a mobile device\r\n   */\n  detectMobileDevice() {\n    // First check client API if available\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    if (this._context && this._context.client && this._context.client.getFormFactor) {\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      var formFactor = this._context.client.getFormFactor();\n      if (formFactor === 2) {\n        // 2 = phone\n        return true;\n      }\n    }\n    // Fallback to user agent detection\n    var userAgent = navigator.userAgent || navigator.vendor ||\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    window.opera;\n    var mobileRegex = /android|webos|iphone|ipad|ipod|blackberry|iemobile|opera mini/i;\n    return mobileRegex.test(userAgent.toLowerCase());\n  }\n  // Show error message in the error label\n  showError(message) {\n    if (this.errorLabel) {\n      this.errorLabel.textContent = message;\n      this.errorLabel.style.color = '#e74c3c';\n      this.errorLabel.style.backgroundColor = '#fadbd8';\n      this.errorLabel.style.display = 'block';\n      // Auto-hide error after 5 seconds\n      setTimeout(() => {\n        if (this.errorLabel) {\n          this.errorLabel.style.display = 'none';\n        }\n      }, 5000);\n    }\n  }\n  // Show success message\n  showSuccess(message) {\n    if (this.errorLabel) {\n      this.errorLabel.textContent = message;\n      this.errorLabel.style.color = '#2ecc71';\n      this.errorLabel.style.backgroundColor = '#d5f5e3';\n      this.errorLabel.style.display = 'block';\n      // Auto-hide success message after 5 seconds\n      setTimeout(() => {\n        if (this.errorLabel) {\n          this.errorLabel.style.display = 'none';\n        }\n      }, 5000);\n    }\n  }\n  // Clear error message\n  clearError() {\n    if (this.errorLabel) {\n      this.errorLabel.style.display = 'none';\n    }\n  }\n  // Show info message\n  showInfo(message) {\n    if (this.errorLabel) {\n      this.errorLabel.textContent = message;\n      this.errorLabel.style.color = '#3498db';\n      this.errorLabel.style.backgroundColor = '#ebf5fb';\n      this.errorLabel.style.display = 'block';\n      // Auto-hide info message after 5 seconds\n      setTimeout(() => {\n        if (this.errorLabel) {\n          this.errorLabel.style.display = 'none';\n        }\n      }, 5000);\n    }\n  }\n  /**\r\n   * Process video upload after format checks\r\n   * @param file The file to process\r\n   */\n  processVideoUpload(file) {\n    this.showLoading(true);\n    this.toBase64String(file, (file, text) => {\n      var type = file.type;\n      // Performance optimization: Create entity object once\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      var notesEntity = {};\n      // Use more efficient regex to handle different video types\n      var fileContent = text.replace(/^data:[^;]+;base64,/, \"\");\n      // Set properties efficiently in a batch\n      Object.assign(notesEntity, {\n        \"documentbody\": fileContent,\n        \"filename\": file.name,\n        \"filesize\": file.size,\n        \"mimetype\": file.type,\n        \"subject\": file.name,\n        \"notetext\": \"Video Attachment of \" + this.entityReference.typeName,\n        \"objecttypecode\": this.entityReference.typeName,\n        [\"objectid_\".concat(this.entityReference.typeName, \"@odata.bind\")]: \"/\".concat(this.CollectionNameFromLogicalName(this.entityReference.typeName), \"(\").concat(this.entityReference.id, \")\")\n      });\n      // Check for existing video for this entity and set the annotation ID\n      this.checkIsExistingVideo(this.entityReference.id).then(annotationId => {\n        // If we have an annotation ID, update it\n        if (annotationId) {\n          this.currentAnnotationId = annotationId;\n          this.updateAttachment(annotationId, notesEntity);\n        } else {\n          // No existing annotation, create a new one\n          this.currentAnnotationId = null;\n          this.createNewAnnotation(notesEntity);\n        }\n        return annotationId;\n      }).catch(error => {\n        this.showLoading(false);\n        console.error(\"Error checking for existing video:\", error);\n        // Create a new annotation as fallback\n        this.createNewAnnotation(notesEntity);\n        return error;\n      });\n    });\n  }\n  /**\r\n   * Create a new annotation record\r\n   * @param notesEntity The annotation data\r\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  createNewAnnotation(notesEntity) {\n    // Show loading while creating\n    this.showLoading(true);\n    this.showUploadButton(false);\n    this.hideVideoPlayer();\n    // Use standard WebAPI - it handles offline mode automatically\n    this._context.webAPI.createRecord(\"annotation\", notesEntity).then(response => {\n      // Record successfully created\n      console.log(\"Annotation created:\", response);\n      this.currentAnnotationId = response.id;\n      this.showDeleteButton();\n      this.showSuccess(\"Uploaded video successfully!!\");\n      // Retrieve the created video to display it\n      this._context.webAPI.retrieveRecord(\"annotation\", response.id, \"?$select=documentbody,mimetype,filename\").then(annotation => {\n        this.processRetrievedAnnotation(annotation);\n        return annotation;\n      }).catch(retrieveError => {\n        this.showLoading(false);\n        this.showUploadButton(true);\n        console.error(\"Error retrieving created video:\", retrieveError);\n        return retrieveError;\n      });\n      return response;\n    })\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    .catch(errorResponse => {\n      // Error handling code here - record failed to be created\n      this.showLoading(false);\n      this.showUploadButton(true);\n      console.log(\"Error creating annotation:\", errorResponse);\n      this.showError(\"Unable to upload video!!\");\n      return errorResponse;\n    });\n  }\n  /**\r\n   * Update an existing attachment\r\n   * @param id The annotation id to update\r\n   * @param data The updated data\r\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  updateAttachment(id, data) {\n    // Show loading while updating, hide video player and upload button\n    this.showLoading(true);\n    this.showUploadButton(false);\n    this.hideVideoPlayer();\n    // Remove any properties that can't be updated\n    // delete data[`objectid_${this.entityReference.typeName}@odata.bind`];\n    // Use standard WebAPI - it handles offline mode automatically\n    this._context.webAPI.updateRecord(\"annotation\", id, data).then(() => {\n      this.showSuccess(\"Video updated successfully!\");\n      // Retrieve the updated video to display it\n      this._context.webAPI.retrieveRecord(\"annotation\", id, \"?$select=documentbody,mimetype,filename\").then(annotation => {\n        this.processRetrievedAnnotation(annotation);\n        return annotation;\n      }).catch(retrieveError => {\n        this.showLoading(false);\n        this.showUploadButton(true);\n        console.error(\"Error retrieving updated video:\", retrieveError);\n        return retrieveError;\n      });\n      return true;\n    }).catch(error => {\n      this.showLoading(false);\n      this.showUploadButton(true);\n      console.error(\"Error updating video:\", error);\n      this.showError(\"Failed to update video.\");\n      return error;\n    });\n  }\n  /**\r\n   * Clear the video player\r\n   */\n  clearVideoPlayer() {\n    var videoElement = document.getElementById('videoElement');\n    if (videoElement) {\n      videoElement.pause();\n      videoElement.src = \"\";\n      videoElement.load();\n    }\n    // Also hide the video name label and video player\n    this.hideVideoNameLabel();\n    this.hideVideoPlayer();\n  }\n  /**\r\n   * Check for existing video attachments for this record\r\n   */\n  checkForExistingVideo() {\n    try {\n      if (!this.entityReference.id) {\n        this.showLoading(false);\n        this.showUploadButton(true); // Show upload button if no entity ID\n        this.debugInfo('No entity ID found');\n        return;\n      }\n      // Show loading state - this happens first\n      this.showLoading(true);\n      this.showUploadButton(false); // Hide upload button during loading\n      this.hideVideoPlayer(); // Ensure player is hidden during loading\n      this.debugInfo(\"Entity ID: \".concat(this.entityReference.id));\n      // Check for existing video and get its ID\n      var query = \"$filter=_objectid_value eq '\".concat(this.entityReference.id, \"'\");\n      this.debugInfo(\"Query for existing video: \".concat(query));\n      this.checkIsExistingVideo(this.entityReference.id).then(annotationId => {\n        if (annotationId) {\n          // We found a video, set the annotation ID\n          this.currentAnnotationId = annotationId;\n          this.debugInfo(\"Found video with ID: \".concat(annotationId));\n          // Keep loading visible while retrieving full video data\n          // Loading will be hidden after video is rendered\n          // Retrieve the full video data\n          var selectQuery = \"?$select=documentbody,mimetype,filename\";\n          this.debugInfo(\"Retrieving full video data: \".concat(selectQuery));\n          return this._context.webAPI.retrieveRecord(\"annotation\", annotationId, selectQuery).then(annotation => {\n            this.debugInfo(\"Retrieved annotation: \".concat(annotation.filename, \", type: \").concat(annotation.mimetype));\n            this.processRetrievedAnnotation(annotation);\n            return annotation;\n          });\n        } else {\n          // No video found - hide loading and show upload button\n          this.showLoading(false);\n          this.showUploadButton(true);\n          this.debugInfo('No existing video found');\n          // Ensure everything else is hidden\n          this.currentAnnotationId = null;\n          this.hideVideoPlayer();\n          this.hideDeleteButton();\n          this.hideVideoNameLabel();\n          return null;\n        }\n      }).catch(error => {\n        // Error - hide loading and show upload button\n        this.showLoading(false);\n        this.showUploadButton(true);\n        this.debugInfo(\"Error checking video: \".concat(this.formatError(error)));\n        console.log(\"Error fetching existing videos:\", error);\n        // Don't show an error to the user, just log it\n        return error;\n      });\n    } catch (error) {\n      // Error - hide loading and show upload button\n      this.showLoading(false);\n      this.showUploadButton(true);\n      this.debugInfo(\"Exception in checkForExistingVideo: \".concat(this.formatError(error)));\n      console.log(\"Error fetching existing videos:\", error);\n    }\n  }\n  /**\r\n   * Standard annotation query using the WebAPI\r\n   * @param entityReferenceId Entity ID to query for\r\n   * @param resolve Promise resolve function\r\n   */\n  standardAnnotationQuery(entityReferenceId, resolve) {\n    // Use OData query syntax \n    var oDataQuery = [\"$select=annotationid\", \"$filter=_objectid_value eq '\".concat(entityReferenceId, \"'\"), \"$orderby=createdon desc\", \"$top=1\"].join(\"&\");\n    this.debugInfo(\"Standard query: ?\".concat(oDataQuery));\n    // Use standard WebAPI\n    this._context.webAPI.retrieveMultipleRecords(\"annotation\", \"?\".concat(oDataQuery)).then(result => {\n      if (result.entities && result.entities.length > 0) {\n        var annotationId = result.entities[0].annotationid;\n        this.debugInfo(\"Found annotation ID: \".concat(annotationId));\n        resolve(annotationId);\n      } else {\n        this.debugInfo('No annotation found');\n        resolve(\"\");\n      }\n      return result;\n    }).catch(error => {\n      this.debugInfo(\"Query error: \".concat(this.formatError(error)));\n      resolve(\"\");\n      return error;\n    });\n  }\n  /**\r\n   * Process a retrieved annotation record\r\n   * @param annotation The annotation record to process\r\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  processRetrievedAnnotation(annotation) {\n    this.currentAnnotationId = annotation.annotationid;\n    this.showDeleteButton();\n    // Check if we need to get the actual file content\n    if (annotation.documentbody) {\n      // Already have document body in the query results\n      var body = \"data:\".concat(annotation.mimetype, \";base64,\").concat(annotation.documentbody);\n      // Update video name label\n      this.updateVideoNameLabel(annotation.filename);\n      // Now that we have the video data, render it to the player\n      this.renderToPlayer(body, annotation.mimetype);\n      // Now that video is rendered, hide loading and show upload button\n      this.showLoading(false);\n      this.showUploadButton(true);\n    } else {\n      // Need to get the file content separately\n      this.showToPlayer(this._context, annotation.annotationid);\n    }\n  }\n  /**\r\n   * Show the delete button\r\n   */\n  showDeleteButton() {\n    var deleteButton = document.getElementById('deleteVideoBtn');\n    if (deleteButton) {\n      deleteButton.style.display = 'inline-block';\n    }\n  }\n  /**\r\n   * Hide the delete button\r\n   */\n  hideDeleteButton() {\n    var deleteButton = document.getElementById('deleteVideoBtn');\n    if (deleteButton) {\n      deleteButton.style.display = 'none';\n    }\n  }\n  /**\r\n   * Updates a record using the offline API\r\n   * @param entityName - Logical name of the entity\r\n   * @param id - ID of the record to update\r\n   * @param data - Record data\r\n   * @returns Promise\r\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  updateRecordOffline(entityName, id, data) {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    return this._context.Xrm.WebApi.offline.updateRecord(entityName, id, data);\n  }\n  /**\r\n   * Updates a record using the online API\r\n   * @param entityName - Logical name of the entity\r\n   * @param id - ID of the record to update\r\n   * @param data - Record data\r\n   * @returns Promise\r\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  updateRecordOnline(entityName, id, data) {\n    return this._context.webAPI.updateRecord(entityName, id, data);\n  }\n  /**\r\n   * Deletes a record using the offline API\r\n   * @param entityName - Logical name of the entity\r\n   * @param id - ID of the record to delete\r\n   * @returns Promise\r\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  deleteRecordOffline(entityName, id) {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    return this._context.Xrm.WebApi.offline.deleteRecord(entityName, id);\n  }\n  /**\r\n   * Deletes a record using the online API\r\n   * @param entityName - Logical name of the entity\r\n   * @param id - ID of the record to delete\r\n   * @returns Promise\r\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  deleteRecordOnline(entityName, id) {\n    return this._context.webAPI.deleteRecord(entityName, id);\n  }\n  /**\r\n   * Called when any value in the property bag has changed. This includes field values, data-sets, global values such as container height and width, offline status, control metadata values such as label, visible, etc.\r\n   * @param context The entire property bag available to control via Context Object; It contains values as set up by the customizer mapped to names defined in the manifest, as well as utility functions\r\n   */\n  updateView(context) {\n    // Add code to update control view\n  }\n  /**\r\n   * It is called by the framework prior to a control receiving new data.\r\n   * @returns an object based on nomenclature defined in manifest, expecting object[s] for property marked as \"bound\" or \"output\"\r\n   */\n  getOutputs() {\n    return {};\n  }\n  /**\r\n   * Called when the control is to be removed from the DOM tree. Controls should use this call for cleanup.\r\n   * i.e. cancelling any pending remote calls, removing listeners, etc.\r\n   */\n  destroy() {\n    // Add code to cleanup control if necessary\n  }\n  // Check if video format is supported by the browser\n  isVideoFormatSupported(mimeType) {\n    var supportedFormats = ['video/mp4', 'video/webm', 'video/ogg', 'video/quicktime', 'video/x-msvideo', 'video/x-ms-wmv'];\n    return supportedFormats.includes(mimeType);\n  }\n  /**\r\n   * Update the video name label\r\n   * @param filename The filename to display\r\n   */\n  updateVideoNameLabel(filename) {\n    if (this.videoNameLabel) {\n      this.videoNameLabel.textContent = \"\".concat(filename);\n      this.videoNameLabel.style.display = 'block';\n    }\n  }\n  /**\r\n   * Hide the video name label\r\n   */\n  hideVideoNameLabel() {\n    if (this.videoNameLabel) {\n      this.videoNameLabel.style.display = 'none';\n    }\n  }\n  /**\r\n   * Show or hide the loading indicator\r\n   */\n  showLoading(show) {\n    this.isLoading = show;\n    // Toggle loading indicator visibility\n    if (this.loadingLabel) {\n      this.loadingLabel.style.display = show ? 'block' : 'none';\n    }\n  }\n  /**\r\n   * Show the video player\r\n   */\n  showVideoPlayer() {\n    if (this.videoContainer) {\n      this.videoContainer.style.display = 'block';\n    }\n  }\n  /**\r\n   * Hide the video player\r\n   */\n  hideVideoPlayer() {\n    if (this.videoContainer) {\n      this.videoContainer.style.display = 'none';\n    }\n  }\n  /**\r\n   * Show or hide the upload button\r\n   */\n  showUploadButton(show) {\n    // Upload section visibility toggle\n    var uploadSection = document.getElementById('uploadSection');\n    if (uploadSection) {\n      uploadSection.style.display = show ? 'flex' : 'none';\n    }\n  }\n  /**\r\n   * Display debug information in the debug label\r\n   * @param info The debug information to display\r\n   */\n  debugInfo(info) {\n    if (!this.isDebugMode || !this.debugLabel) return;\n    var timestamp = new Date().toISOString().slice(11, 19); // HH:MM:SS\n    var currentContent = this.debugLabel.textContent || '';\n    // Limit the number of lines to avoid excessive content\n    var lines = currentContent.split('\\n');\n    if (lines.length > 20) {\n      lines.shift(); // Remove oldest line\n    }\n    // Add new line with timestamp\n    lines.push(\"[\".concat(timestamp, \"] \").concat(info));\n    this.debugLabel.textContent = lines.join('\\n');\n    this.debugLabel.scrollTop = this.debugLabel.scrollHeight; // Auto-scroll to bottom\n  }\n  /**\r\n   * Display error details for debugging, handling unknown type\r\n   * @param error The error to format\r\n   * @returns A string representation of the error\r\n   */\n  formatError(error) {\n    if (error instanceof Error) {\n      return error.message;\n    } else if (typeof error === 'string') {\n      return error;\n    } else if (error && typeof error === 'object') {\n      try {\n        return JSON.stringify(error);\n      } catch (_a) {\n        return 'Object error (non-serializable)';\n      }\n    }\n    return 'Unknown error';\n  }\n}\n\n//# sourceURL=webpack://pcf_tools_652ac3f36e1e4bca82eb3c1dc44e6fad/./AttachmentVideoControl/index.ts?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The require scope
/******/ 	var __webpack_require__ = {};
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = {};
/******/ 	__webpack_modules__["./AttachmentVideoControl/index.ts"](0, __webpack_exports__, __webpack_require__);
/******/ 	pcf_tools_652ac3f36e1e4bca82eb3c1dc44e6fad = __webpack_exports__;
/******/ 	
/******/ })()
;
if (window.ComponentFramework && window.ComponentFramework.registerControl) {
	ComponentFramework.registerControl('AttachmentVideoControl.AttachmentVideoControl', pcf_tools_652ac3f36e1e4bca82eb3c1dc44e6fad.AttachmentVideoControl);
} else {
	var AttachmentVideoControl = AttachmentVideoControl || {};
	AttachmentVideoControl.AttachmentVideoControl = pcf_tools_652ac3f36e1e4bca82eb3c1dc44e6fad.AttachmentVideoControl;
	pcf_tools_652ac3f36e1e4bca82eb3c1dc44e6fad = undefined;
}